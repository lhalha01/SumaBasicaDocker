trigger:
  branches:
    include:
      - main

pr:
  branches:
    include:
      - main

variables:
  azureServiceConnection: 'LabsConn'
  resourceGroup: 'AHL_resources'
  aksClusterName: 'KSuma'
  acrName: 'acrsuma'
  acrLoginServer: 'acrsuma.azurecr.io'
  trivyImageFailSeverities: 'CRITICAL'
  trivyConfigFailSeverities: 'HIGH,CRITICAL'
  ghcrPat: ''
  keyVaultName: 'AHLSecretos'
  ghcrUser: 'lhalha01'
  namespace: 'calculadora-suma'
  terraformWorkingDir: 'infra/terraform'
  sonarOrganization: 'lhalha01'
  sonarProjectKey: 'lhalha01_SumaBasicaDocker'
  sonarProjectName: 'SumaBasicaDocker'
  slackWebhookUrl: ''  # Stored in Key Vault as: SLACKWEBHOOKURL

stages:
  - stage: TerraformPlan
    displayName: 'Terraform Plan'
    jobs:
      - job: Plan
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: Bash@3
            displayName: 'Install Terraform 1.6.6'
            inputs:
              targetType: 'inline'
              script: |
                set -euo pipefail
                curl -fsSL -o terraform.zip https://releases.hashicorp.com/terraform/1.6.6/terraform_1.6.6_linux_amd64.zip
                unzip -o terraform.zip
                sudo mv terraform /usr/local/bin/terraform
                terraform version

          - task: AzureCLI@2
            displayName: 'Terraform init/validate/plan'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -euo pipefail
                cd "$(terraformWorkingDir)"
                terraform init
                terraform validate
                terraform plan \
                  -var="resource_group_name=$(resourceGroup)" \
                  -var="existing_aks_name=$(aksClusterName)" \
                  -var="kubelet_identity_object_id=$(AKS_KUBELET_OBJECT_ID)"

          - task: AzureCLI@2
            displayName: 'Helm install kube-prometheus-stack (idempotente)'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -euo pipefail
                az aks get-credentials -g "$(resourceGroup)" -n "$(aksClusterName)" --overwrite-existing

                # Instalar Helm si no está disponible
                if ! command -v helm &>/dev/null; then
                  curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
                fi

                helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
                helm repo update

                kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -

                # Obtener password de Grafana desde Key Vault (fallback a valor por defecto)
                GRAFANA_PASS=$(az keyvault secret show \
                  --vault-name "$(keyVaultName)" \
                  --name "grafana-admin-password" \
                  --query value -o tsv 2>/dev/null || echo "SumaAdmin2026!")

                helm upgrade --install kube-prometheus-stack \
                  prometheus-community/kube-prometheus-stack \
                  --namespace monitoring \
                  --values k8s/monitoring/prometheus-values.yaml \
                  --set grafana.adminPassword="$GRAFANA_PASS" \
                  --timeout 15m \
                  --wait

                # Aplicar ServiceMonitor para suma-proxy
                kubectl apply -f k8s/monitoring/servicemonitor-proxy.yaml

                echo "✓ kube-prometheus-stack listo en namespace monitoring"
                echo "Grafana LoadBalancer:"
                kubectl get svc -n monitoring kube-prometheus-stack-grafana \
                  -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || true
                echo ""

  - stage: CodeQuality
    displayName: 'SonarCloud Code Quality'
    dependsOn: TerraformPlan
    jobs:
      - job: SonarAnalysis
        displayName: 'SonarCloud static analysis'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 0

          - task: AzureKeyVault@2
            displayName: 'Load secrets from Key Vault'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              KeyVaultName: '$(keyVaultName)'
              SecretsFilter: 'SONARTOKEN,SLACKWEBHOOKURL'
              RunAsPreJob: false

          - task: Bash@3
            displayName: 'Run SonarCloud analysis (CLI)'
            env:
              SONAR_TOKEN: $(SONARTOKEN)
              SONAR_ORGANIZATION: $(sonarOrganization)
              SONAR_PROJECT_KEY: $(sonarProjectKey)
              SONAR_PROJECT_NAME: $(sonarProjectName)
            inputs:
              targetType: 'inline'
              script: |
                set -euo pipefail

                SCANNER_VERSION="6.2.1.4610"
                curl -fsSL -o sonar-scanner.zip \
                  "https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-${SCANNER_VERSION}-linux-x64.zip"
                unzip -q sonar-scanner.zip
                export PATH="$PWD/sonar-scanner-${SCANNER_VERSION}-linux-x64/bin:$PATH"

                sonar-scanner \
                  -Dsonar.host.url=https://sonarcloud.io \
                  -Dsonar.token="$SONAR_TOKEN" \
                  -Dsonar.organization="$SONAR_ORGANIZATION" \
                  -Dsonar.projectKey="$SONAR_PROJECT_KEY" \
                  -Dsonar.projectName="$SONAR_PROJECT_NAME" \
                  -Dsonar.sources=. \
                  -Dsonar.exclusions="**/__pycache__/**,**/trivy-reports/**,infra/**,k8s/**" \
                  -Dsonar.python.version=3.11 || true

          - task: Bash@3
            displayName: 'Fetch SonarCloud results and notify Slack'
            condition: succeededOrFailed()
            env:
              SONAR_TOKEN: $(SONARTOKEN)
              SONAR_PROJECT_KEY: $(sonarProjectKey)
              SLACK_WEBHOOK_URL: $(SLACKWEBHOOKURL)
              BUILD_BUILDID: $(Build.BuildId)
            inputs:
              targetType: 'inline'
              script: |
                set +e
                python3 - << 'PYEOF'
                import json, os, sys, time, urllib.request, urllib.parse, base64
                TOKEN     = os.environ.get("SONAR_TOKEN", "")
                PROJ_KEY  = os.environ.get("SONAR_PROJECT_KEY", "lhalha01_SumaBasicaDocker")
                SLACK_URL = os.environ.get("SLACK_WEBHOOK_URL", "")
                BUILD_ID  = os.environ.get("BUILD_BUILDID", "?")
                DASH_URL  = f"https://sonarcloud.io/project/overview?id={PROJ_KEY}"
                if not TOKEN:
                  print("SONAR_TOKEN not set — skipping")
                  sys.exit(0)
                def sonar_get(path):
                  url = f"https://sonarcloud.io/api/{path}"
                  req = urllib.request.Request(url)
                  creds = base64.b64encode(f"{TOKEN}:".encode()).decode()
                  req.add_header("Authorization", f"Basic {creds}")
                  with urllib.request.urlopen(req, timeout=20) as r:
                    return json.loads(r.read())
                report_file = ".scannerwork/report-task.txt"
                if os.path.exists(report_file):
                  ce_id = None
                  with open(report_file) as fh:
                    for line in fh:
                      if line.startswith("ceTaskId="):
                        ce_id = line.strip().split("=", 1)[1]
                  if ce_id:
                    print(f"Waiting for CE task {ce_id}...")
                    for _ in range(24):
                      try:
                        resp = sonar_get(f"ce/task?id={ce_id}")
                        st = resp["task"]["status"]
                        print(f"  status: {st}")
                        if st in ("SUCCESS", "FAILED", "CANCELLED"):
                          break
                      except Exception as err:
                        print(f"  poll error: {err}")
                      time.sleep(5)
                METRICS = "bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density,ncloc,reliability_rating,security_rating,sqale_rating"
                try:
                  mr = sonar_get(f"measures/component?component={urllib.parse.quote(PROJ_KEY)}&metricKeys={METRICS}")
                  qr = sonar_get(f"qualitygates/project_status?projectKey={urllib.parse.quote(PROJ_KEY)}")
                except Exception as err:
                  print(f"API error: {err} — skipping notification")
                  sys.exit(0)
                m   = {x["metric"]: x.get("value", "\u2014") for x in mr["component"]["measures"]}
                qg  = qr["projectStatus"]["status"]
                RAT = {"1": "A", "2": "B", "3": "C", "4": "D", "5": "E"}
                def rfmt(v): return RAT.get(str(int(float(v))), v) if v not in ("\u2014", "") else "\u2014"
                def pfmt(v): return f"{float(v):.1f}%" if v not in ("\u2014", "") else "\u2014"
                qg_ok   = qg == "OK"
                qg_icon = "\u2705" if qg_ok else "\u274c"
                color   = "#36a64f" if qg_ok else "#d9534f"
                label   = "Passed" if qg_ok else "Failed"
                print(f"{qg_icon} Quality Gate: {label}")
                print(f"Bugs={m.get('bugs','\u2014')} Vuln={m.get('vulnerabilities','\u2014')} Smells={m.get('code_smells','\u2014')} Coverage={pfmt(m.get('coverage','\u2014'))}")
                if not SLACK_URL or not SLACK_URL.startswith("https://"):
                  print("SLACK_WEBHOOK_URL not configured — skipping notification")
                  sys.exit(0)
                payload = {
                  "attachments": [{
                    "color": color,
                    "blocks": [
                      {"type": "header", "text": {"type": "plain_text", "text": f"{qg_icon} SonarCloud \u2014 SumaBasicaDocker #{BUILD_ID}"}},
                      {"type": "section", "fields": [
                        {"type": "mrkdwn", "text": f"*Quality Gate:* {qg_icon} {label}"},
                        {"type": "mrkdwn", "text": f"*L\u00edneas:* {m.get('ncloc','\u2014')}"},
                        {"type": "mrkdwn", "text": f"*Bugs:* {m.get('bugs','\u2014')}"},
                        {"type": "mrkdwn", "text": f"*Vulnerabilidades:* {m.get('vulnerabilities','\u2014')}"},
                        {"type": "mrkdwn", "text": f"*Code Smells:* {m.get('code_smells','\u2014')}"},
                        {"type": "mrkdwn", "text": f"*Cobertura:* {pfmt(m.get('coverage','\u2014'))}"},
                        {"type": "mrkdwn", "text": f"*Duplicaci\u00f3n:* {pfmt(m.get('duplicated_lines_density','\u2014'))}"},
                        {"type": "mrkdwn", "text": f"*Fiabilidad:* {rfmt(m.get('reliability_rating','\u2014'))}  *Seguridad:* {rfmt(m.get('security_rating','\u2014'))}  *Mantenib.:* {rfmt(m.get('sqale_rating','\u2014'))}"},
                      ]},
                      {"type": "actions", "elements": [
                        {"type": "button", "text": {"type": "plain_text", "text": "Ver en SonarCloud"}, "url": DASH_URL, "style": "primary"}
                      ]}
                    ]
                  }]
                }
                try:
                  data = json.dumps(payload).encode()
                  req2 = urllib.request.Request(SLACK_URL, data=data, headers={"Content-Type": "application/json"})
                  with urllib.request.urlopen(req2, timeout=10) as resp2:
                    print(f"Slack: HTTP {resp2.status}")
                except Exception as slack_err:
                  print(f"Slack notification failed (non-blocking): {slack_err}")
                PYEOF
                true

  - stage: BuildAndPush
    displayName: 'Build and Push Proxy Image'
    dependsOn: CodeQuality
    jobs:
      - job: BuildPush
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: 'Build and push to ACR'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -euo pipefail
                ACR_NAME="$(acrName)"
                ACR_LOGIN_SERVER="$(acrLoginServer)"

                if [ -z "$ACR_NAME" ]; then
                  ACR_NAME=$(az acr list -g "$(resourceGroup)" --query "[0].name" -o tsv)
                fi

                if [ -z "$ACR_NAME" ]; then
                  ACR_TOTAL=$(az acr list --query "length(@)" -o tsv)
                  if [ "$ACR_TOTAL" = "1" ]; then
                    ACR_NAME=$(az acr list --query "[0].name" -o tsv)
                  elif [ "$ACR_TOTAL" = "0" ]; then
                    echo "ERROR: No se encontró ningún ACR en la suscripción. Crea uno o define 'acrName'."
                    exit 1
                  else
                    echo "ERROR: Se encontraron múltiples ACR en la suscripción y ninguno en $(resourceGroup). Define 'acrName'."
                    az acr list --query "[].{name:name,resourceGroup:resourceGroup,loginServer:loginServer}" -o table
                    exit 1
                  fi
                fi

                if [ -z "$ACR_NAME" ]; then
                  echo "ERROR: No se encontró ACR en el resource group $(resourceGroup). Define 'acrName'."
                  exit 1
                fi

                if [ -z "$ACR_LOGIN_SERVER" ]; then
                  ACR_LOGIN_SERVER=$(az acr show -n "$ACR_NAME" --query loginServer -o tsv)
                fi

                if [ -z "$ACR_LOGIN_SERVER" ]; then
                  echo "ERROR: No se pudo resolver loginServer para ACR '$ACR_NAME'. Define 'acrLoginServer'."
                  exit 1
                fi

                echo "##vso[task.setvariable variable=acrName]$ACR_NAME"
                echo "##vso[task.setvariable variable=acrLoginServer]$ACR_LOGIN_SERVER"

                az acr login --name "$ACR_NAME"
                IMAGE="$ACR_LOGIN_SERVER/suma-proxy:$(Build.SourceVersion)"
                docker build -t "$IMAGE" .
                docker push "$IMAGE"
                docker tag "$IMAGE" "$ACR_LOGIN_SERVER/suma-proxy:latest"
                docker push "$ACR_LOGIN_SERVER/suma-proxy:latest"

                echo "##vso[task.setvariable variable=proxyImage;isOutput=true]$IMAGE"
            name: buildMeta

  - stage: SecurityScan
    displayName: 'Trivy Security Scan'
    dependsOn: BuildAndPush
    jobs:
      - job: TrivyImageScan
        displayName: 'Scan image with Trivy'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self

          - task: AzureCLI@2
            displayName: 'Install Trivy and pull image'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -euo pipefail

                ACR_NAME="$(acrName)"
                ACR_LOGIN_SERVER="$(acrLoginServer)"

                if [ -z "$ACR_NAME" ]; then
                  ACR_NAME=$(az acr list -g "$(resourceGroup)" --query "[0].name" -o tsv)
                fi

                if [ -z "$ACR_NAME" ]; then
                  ACR_TOTAL=$(az acr list --query "length(@)" -o tsv)
                  if [ "$ACR_TOTAL" = "1" ]; then
                    ACR_NAME=$(az acr list --query "[0].name" -o tsv)
                  elif [ "$ACR_TOTAL" = "0" ]; then
                    echo "ERROR: No se encontró ningún ACR en la suscripción. Crea uno o define 'acrName'."
                    exit 1
                  else
                    echo "ERROR: Se encontraron múltiples ACR en la suscripción y ninguno en $(resourceGroup). Define 'acrName'."
                    az acr list --query "[].{name:name,resourceGroup:resourceGroup,loginServer:loginServer}" -o table
                    exit 1
                  fi
                fi

                if [ -z "$ACR_LOGIN_SERVER" ]; then
                  ACR_LOGIN_SERVER=$(az acr show -n "$ACR_NAME" --query loginServer -o tsv)
                fi

                if [ -z "$ACR_LOGIN_SERVER" ]; then
                  echo "ERROR: No se pudo resolver loginServer para ACR '$ACR_NAME'. Define 'acrLoginServer'."
                  exit 1
                fi

                az acr login --name "$ACR_NAME"

                TRIVY_VERSION="0.57.1"
                curl -sfL "https://github.com/aquasecurity/trivy/releases/download/v${TRIVY_VERSION}/trivy_${TRIVY_VERSION}_Linux-64bit.tar.gz" -o trivy.tar.gz
                tar -xzf trivy.tar.gz trivy
                sudo mv trivy /usr/local/bin/trivy
                trivy --version

                IMAGE="$ACR_LOGIN_SERVER/suma-proxy:$(Build.SourceVersion)"
                docker pull "$IMAGE"

          - task: Bash@3
            displayName: 'Generate Trivy reports (JSON/SARIF)'
            inputs:
              targetType: 'inline'
              script: |
                set -euo pipefail
                IMAGE="$(acrLoginServer)/suma-proxy:$(Build.SourceVersion)"
                mkdir -p trivy-reports

                trivy image \
                  --severity "$(trivyImageFailSeverities)" \
                  --skip-files /usr/local/bin/kubectl \
                  --ignore-unfixed \
                  --exit-code 0 \
                  --no-progress \
                  --format json \
                  --output trivy-reports/trivy-report.json \
                  "$IMAGE"

                trivy image \
                  --severity "$(trivyImageFailSeverities)" \
                  --skip-files /usr/local/bin/kubectl \
                  --ignore-unfixed \
                  --exit-code 0 \
                  --no-progress \
                  --format sarif \
                  --output trivy-reports/trivy-report.sarif \
                  "$IMAGE"

                trivy config \
                  --severity "$(trivyConfigFailSeverities)" \
                  --exit-code 0 \
                  --skip-dirs trivy-reports \
                  --quiet \
                  --format json \
                  --output trivy-reports/trivy-config-report.json \
                  .

                trivy config \
                  --severity "$(trivyConfigFailSeverities)" \
                  --exit-code 0 \
                  --skip-dirs trivy-reports \
                  --quiet \
                  --format sarif \
                  --output trivy-reports/trivy-config-report.sarif \
                  .

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Trivy reports'
            condition: always()
            inputs:
              targetPath: '$(System.DefaultWorkingDirectory)/trivy-reports'
              artifact: 'trivy-reports'
              publishLocation: 'pipeline'

          - task: Bash@3
            displayName: 'Trivy security gate'
            inputs:
              targetType: 'inline'
              script: |
                set -euo pipefail
                IMAGE="$(acrLoginServer)/suma-proxy:$(Build.SourceVersion)"

                trivy image \
                  --severity "$(trivyImageFailSeverities)" \
                  --skip-files /usr/local/bin/kubectl \
                  --ignore-unfixed \
                  --exit-code 1 \
                  --no-progress \
                  "$IMAGE"

                trivy config \
                  --severity "$(trivyConfigFailSeverities)" \
                  --exit-code 1 \
                  --skip-dirs trivy-reports \
                  --quiet \
                  .

  - stage: DocsGenerate
    displayName: 'Docs as Code — Build & Push'
    dependsOn: SecurityScan
    jobs:
      - job: BuildDocs
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - checkout: self
            fetchDepth: 0

          - task: AzureKeyVault@2
            displayName: 'Load SONARTOKEN from Key Vault'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              KeyVaultName: '$(keyVaultName)'
              SecretsFilter: 'SONARTOKEN'
              RunAsPreJob: false

          - task: Bash@3
            displayName: 'Generate SonarCloud report for docs'
            env:
              SONAR_TOKEN: $(SONARTOKEN)
              SONAR_PROJECT_KEY: $(sonarProjectKey)
              BUILD_BUILDID: $(Build.BuildId)
            inputs:
              targetType: 'inline'
              script: |
                set +e
                python3 - << 'PYEOF'
                import json, os, sys, urllib.request, urllib.parse, base64, datetime
                TOKEN     = os.environ.get("SONAR_TOKEN", "")
                PROJ_KEY  = os.environ.get("SONAR_PROJECT_KEY", "lhalha01_SumaBasicaDocker")
                BUILD_ID  = os.environ.get("BUILD_BUILDID", "\u2014")
                NOW       = datetime.datetime.utcnow().strftime("%d/%m/%Y %H:%M UTC")
                DASH_URL  = f"https://sonarcloud.io/project/overview?id={PROJ_KEY}"
                PK        = PROJ_KEY
                PLACEHOLDER = (
                  "# Calidad de C\u00f3digo \u2014 SonarCloud\n\n"
                  '!!! warning "Informe no disponible"\n'
                  f"    No se pudo obtener m\u00e9tricas. Visita [{DASH_URL}]({DASH_URL}).\n"
                )
                if not TOKEN:
                  print("SONAR_TOKEN not set \u2014 writing placeholder")
                  open("docs/sonarcloud.md", "w").write(PLACEHOLDER)
                  sys.exit(0)
                def sonar_get(path):
                  url = f"https://sonarcloud.io/api/{path}"
                  req = urllib.request.Request(url)
                  creds = base64.b64encode(f"{TOKEN}:".encode()).decode()
                  req.add_header("Authorization", f"Basic {creds}")
                  with urllib.request.urlopen(req, timeout=20) as r:
                    return json.loads(r.read())
                try:
                  METRICS = "bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density,ncloc,reliability_rating,security_rating,sqale_rating"
                  mr = sonar_get(f"measures/component?component={urllib.parse.quote(PK)}&metricKeys={METRICS}")
                  qr = sonar_get(f"qualitygates/project_status?projectKey={urllib.parse.quote(PK)}")
                except Exception as err:
                  print(f"API error: {err} \u2014 writing placeholder")
                  open("docs/sonarcloud.md", "w").write(PLACEHOLDER)
                  sys.exit(0)
                m   = {x["metric"]: x.get("value", "\u2014") for x in mr["component"]["measures"]}
                qg  = qr["projectStatus"]["status"]
                RAT = {"1": "A \u2705", "2": "B \U0001f7e1", "3": "C \U0001f7e0", "4": "D \U0001f534", "5": "E \u274c"}
                def rfmt(v): return RAT.get(str(int(float(v))), v) if v not in ("\u2014", "") else "\u2014"
                def pfmt(v): return f"{float(v):.1f}%" if v not in ("\u2014", "") else "\u2014"
                qg_ok   = qg == "OK"
                qg_icon = "\u2705 Passed" if qg_ok else "\u274c Failed"
                lines = []
                lines.append("# Calidad de C\u00f3digo \u2014 SonarCloud")
                lines.append("")
                lines.append('!!! info "Generaci\u00f3n autom\u00e1tica"')
                lines.append("    Informe generado con la [SonarCloud API](https://sonarcloud.io/web_api) en la pipeline CI/CD.")
                lines.append("")
                lines.append(f"> **\u00daltimo an\u00e1lisis:** {NOW} \u2014 Pipeline **#{BUILD_ID}**")
                lines.append(f"> \U0001f517 [Ver dashboard completo en SonarCloud]({DASH_URL})")
                lines.append("")
                lines.append("---")
                lines.append("")
                lines.append("## Quality Gate")
                lines.append("")
                lines.append("| Estado |")
                lines.append("|:---:|")
                lines.append(f"| **{qg_icon}** |")
                lines.append("")
                lines.append("---")
                lines.append("")
                lines.append("## M\u00e9tricas principales")
                lines.append("")
                lines.append("| M\u00e9trica | Valor |")
                lines.append("|---|---|")
                lines.append(f"| \U0001f41b Bugs | {m.get('bugs','\u2014')} |")
                lines.append(f"| \U0001f512 Vulnerabilidades | {m.get('vulnerabilities','\u2014')} |")
                lines.append(f"| \U0001f300 Code Smells | {m.get('code_smells','\u2014')} |")
                lines.append(f"| \U0001f4ca Cobertura de tests | {pfmt(m.get('coverage','\u2014'))} |")
                lines.append(f"| \U0001f4cb Duplicaci\u00f3n de c\u00f3digo | {pfmt(m.get('duplicated_lines_density','\u2014'))} |")
                lines.append(f"| \U0001f4cf L\u00edneas de c\u00f3digo | {m.get('ncloc','\u2014')} |")
                lines.append("")
                lines.append("---")
                lines.append("")
                lines.append("## Ratings")
                lines.append("")
                lines.append("| Dimensi\u00f3n | Rating |")
                lines.append("|---|---|")
                lines.append(f"| Fiabilidad | {rfmt(m.get('reliability_rating','\u2014'))} |")
                lines.append(f"| Seguridad | {rfmt(m.get('security_rating','\u2014'))} |")
                lines.append(f"| Mantenibilidad | {rfmt(m.get('sqale_rating','\u2014'))} |")
                lines.append("")
                lines.append("---")
                lines.append("")
                lines.append("## Badges en tiempo real")
                lines.append("")
                lines.append(f"[![Quality Gate](https://sonarcloud.io/api/project_badges/measure?project={PK}&metric=alert_status)](https://sonarcloud.io/project/overview?id={PK})")
                lines.append(f"[![Bugs](https://sonarcloud.io/api/project_badges/measure?project={PK}&metric=bugs)](https://sonarcloud.io/project/overview?id={PK})")
                lines.append(f"[![Code Smells](https://sonarcloud.io/api/project_badges/measure?project={PK}&metric=code_smells)](https://sonarcloud.io/project/overview?id={PK})")
                lines.append(f"[![Coverage](https://sonarcloud.io/api/project_badges/measure?project={PK}&metric=coverage)](https://sonarcloud.io/project/overview?id={PK})")
                lines.append(f"[![Duplicated Lines](https://sonarcloud.io/api/project_badges/measure?project={PK}&metric=duplicated_lines_density)](https://sonarcloud.io/project/overview?id={PK})")
                lines.append("")
                with open("docs/sonarcloud.md", "w") as fh:
                  fh.write("\n".join(lines))
                print("\u2713 docs/sonarcloud.md generated")
                PYEOF
                true

          - task: AzureCLI@2
            displayName: 'Generate changelog, build & push docs image'
            inputs:
              azureSubscription: '$(azureServiceConnection)'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                set -euo pipefail

                ACR_NAME="$(acrName)"
                ACR_LOGIN_SERVER="$(acrLoginServer)"

                if [ -z "$ACR_NAME" ]; then
                  ACR_NAME=$(az acr list -g "$(resourceGroup)" --query "[0].name" -o tsv)
                fi
                if [ -z "$ACR_LOGIN_SERVER" ]; then
                  ACR_LOGIN_SERVER=$(az acr show -n "$ACR_NAME" --query loginServer -o tsv)
                fi

                # ── git-cliff: generar changelog ──────────────────────────────
                CLIFF_VERSION="2.4.0"
                curl -fsSL "https://github.com/orhun/git-cliff/releases/download/v${CLIFF_VERSION}/git-cliff-${CLIFF_VERSION}-x86_64-unknown-linux-gnu.tar.gz" \
                  | tar -xz --wildcards "*/git-cliff" --strip-components=1
                sudo mv git-cliff /usr/local/bin/git-cliff
                git-cliff --config cliff.toml --output docs/changelog.md || true

                # ── Build & push docs image (deploy se hace en DeployAKS) ─────
                DOCS_IMAGE="$ACR_LOGIN_SERVER/suma-docs:$(Build.BuildId)"

                az acr login --name "$ACR_NAME"
                docker build -f Dockerfile.docs \
                  -t "$DOCS_IMAGE" \
                  -t "$ACR_LOGIN_SERVER/suma-docs:latest" \
                  .
                docker push "$DOCS_IMAGE"
                docker push "$ACR_LOGIN_SERVER/suma-docs:latest"

                echo "✓ Docs image pushed: $DOCS_IMAGE"

  - stage: DeployAKS
    displayName: 'Deploy to AKS'
    dependsOn: DocsGenerate
    jobs:
      - deployment: Deploy
        environment: 'aks-frontal'
        pool:
          vmImage: 'ubuntu-latest'
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: self

                - task: AzureCLI@2
                  displayName: 'AKS deploy workloads'
                  inputs:
                    azureSubscription: '$(azureServiceConnection)'
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      set -euo pipefail

                      ACR_LOGIN_SERVER="$(acrLoginServer)"

                      if [ -z "$ACR_LOGIN_SERVER" ]; then
                        ACR_NAME="$(acrName)"
                        if [ -z "$ACR_NAME" ]; then
                          ACR_NAME=$(az acr list -g "$(resourceGroup)" --query "[0].name" -o tsv)
                        fi

                        if [ -z "$ACR_NAME" ]; then
                          ACR_TOTAL=$(az acr list --query "length(@)" -o tsv)
                          if [ "$ACR_TOTAL" = "1" ]; then
                            ACR_NAME=$(az acr list --query "[0].name" -o tsv)
                          elif [ "$ACR_TOTAL" = "0" ]; then
                            echo "ERROR: No se encontró ningún ACR en la suscripción. Crea uno o define 'acrName'."
                            exit 1
                          else
                            echo "ERROR: Se encontraron múltiples ACR en la suscripción y ninguno en $(resourceGroup). Define 'acrName'."
                            az acr list --query "[].{name:name,resourceGroup:resourceGroup,loginServer:loginServer}" -o table
                            exit 1
                          fi
                        fi

                        if [ -z "$ACR_NAME" ]; then
                          echo "ERROR: No se encontró ACR en el resource group $(resourceGroup). Define 'acrName'."
                          exit 1
                        fi

                        ACR_LOGIN_SERVER=$(az acr show -n "$ACR_NAME" --query loginServer -o tsv)
                      fi

                      if [ -z "$ACR_LOGIN_SERVER" ]; then
                        echo "ERROR: No se pudo resolver 'acrLoginServer'."
                        exit 1
                      fi

                      az aks get-credentials -g "$(resourceGroup)" -n "$(aksClusterName)" --overwrite-existing

                      GHCR_PAT="$(ghcrPat)"

                      if [ -z "$GHCR_PAT" ]; then
                        GHCR_PAT=$(az keyvault secret show \
                          --vault-name "$(keyVaultName)" \
                          --name "github-pat" \
                          --query value -o tsv 2>/dev/null || true)
                      fi

                      if [ -z "$GHCR_PAT" ]; then
                        echo "ERROR: No se pudo obtener github-pat. Define variable secreta 'ghcrPat' en la pipeline o da permisos de secretos al service principal sobre Key Vault $(keyVaultName)."
                        exit 1
                      fi

                      kubectl apply -f k8s/namespace.yaml

                      kubectl create secret docker-registry ghcr-secret \
                        --namespace "$(namespace)" \
                        --docker-server=ghcr.io \
                        --docker-username="$(ghcrUser)" \
                        --docker-password="$GHCR_PAT" \
                        --dry-run=client -o yaml | kubectl apply -f -

                      kubectl apply -f k8s/backend-workloads.yaml
                      kubectl apply -f k8s/proxy-rbac.yaml

                      IMAGE="$ACR_LOGIN_SERVER/suma-proxy:$(Build.SourceVersion)"
                      sed "s|__PROXY_IMAGE__|$IMAGE|g" k8s/proxy-deployment.yaml | kubectl apply -f -
                      kubectl apply -f k8s/proxy-service.yaml

                      kubectl rollout status deployment/suma-proxy -n "$(namespace)" --timeout=600s || {
                        echo ""
                        echo "========== ROLLOUT FAILED — DIAGNOSTICS =========="
                        echo "--- Deployment state ---"
                        kubectl describe deployment suma-proxy -n "$(namespace)"
                        echo "--- Pods ---"
                        kubectl get pods -n "$(namespace)" -l app=suma-proxy -o wide
                        echo "--- Pod events & state ---"
                        kubectl describe pods -n "$(namespace)" -l app=suma-proxy
                        echo "--- Pod logs (last 80 lines) ---"
                        kubectl logs -n "$(namespace)" -l app=suma-proxy --tail=80 --previous 2>/dev/null || \
                        kubectl logs -n "$(namespace)" -l app=suma-proxy --tail=80 2>/dev/null || true
                        echo "=================================================="
                        exit 1
                      }

                      # ── Deploy suma-docs (imagen construida en DocsGenerate) ─
                      DOCS_IMAGE="$ACR_LOGIN_SERVER/suma-docs:$(Build.BuildId)"
                      sed "s|__DOCS_IMAGE__|$DOCS_IMAGE|g" k8s/docs-deployment.yaml | kubectl apply -f -
                      kubectl set image deployment/suma-docs \
                        suma-docs="$DOCS_IMAGE" \
                        -n "$(namespace)" || true
                      kubectl rollout status deployment/suma-docs \
                        -n "$(namespace)" --timeout=120s

                      echo "───────────────────────────────────────────"
                      echo "Docs IP pública:"
                      kubectl get svc suma-docs -n "$(namespace)" \
                        -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || true
                      echo ""
                      echo "───────────────────────────────────────────"

                      kubectl get deployments,services,pods -n "$(namespace)"
